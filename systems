
void Engine::controllerSystem(double dt)
{

  for (auto &[id, movement, controller] : ecs.view<Movement, Controller>())
  {
    // X axis movement
    if (input.isKeyPressed(SDL_SCANCODE_A) == input.isKeyPressed(SDL_SCANCODE_D))
    {
      movement.velocity.x = 0;
    }
    else if (input.isKeyPressed(SDL_SCANCODE_A))
    {
      movement.velocity.x = -1;
    }
    else if (input.isKeyPressed(SDL_SCANCODE_D))
    {
      movement.velocity.x = 1;
    }

    // Y axis movement
    if (input.isKeyPressed(SDL_SCANCODE_W) == input.isKeyPressed(SDL_SCANCODE_S))
    {
      movement.velocity.y = 0;
    }
    else if (input.isKeyPressed(SDL_SCANCODE_W))
    {
      movement.velocity.y = -1;
    }
    else if (input.isKeyPressed(SDL_SCANCODE_S))
    {
      movement.velocity.y = 1;
    }
  }
}

void Engine::movementSystem(double dt)
{
  for (auto &[id, transform, movement] : ecs.view<Transform, Movement>())
  {
    movement.velocity.normalize();
    transform.position.x += movement.walkSpeed.x * movement.velocity.x * dt;
    transform.position.y += movement.walkSpeed.y * movement.velocity.y * dt;

    // Update dir
    if (movement.velocity.x > 0)
    {
      movement.facingDir = Facing::RIGHT;
    }
    else if (movement.velocity.x < 0)
    {
      movement.facingDir = Facing::LEFT;
    }
  }
}

void Engine::movementAnimationSystem(double dt)
{
  for (auto &[id, movement, animator] : ecs.view<Movement, Animator>())
  {
    if (movement.velocity.x || movement.velocity.y)
    {
      switch (movement.facingDir)
      {
      case Facing::RIGHT:
        // animator.
        animator.playAnimation(1);
        break;
      case Facing::LEFT:
      default:
        animator.playAnimation(1, SDL_FLIP_HORIZONTAL);
        break;
      }
    }
    else // ur not moving
    {
      switch (movement.facingDir)
      {
      case Facing::RIGHT:
        animator.playAnimation(0);
        break;
      case Facing::LEFT:
      default:
        animator.playAnimation(0, SDL_FLIP_HORIZONTAL);
        break;
      }
    }
  }
}

void Engine::animationSystem(double dt)
{
  // Change animations here
  // + calculate animation stuff
  for (auto &[id, animator] : ecs.view<Animator>())
  {
    if (!animator.animationsAdded)
    {
      continue;
    }

    Animation *currentAnim = animator.animations[animator.currentAnimation];
    currentAnim->frameTime += dt;
    // Update this animation
    if (currentAnim->frameTime >= currentAnim->frameDuration)
    {
      currentAnim->frameTime = 0;
      currentAnim->currentFrame++;
      currentAnim->currentFrame = currentAnim->currentFrame % currentAnim->frames;
      currentAnim->frameRect.x = (currentAnim->startX * currentAnim->frameRect.w) +
                                 currentAnim->frameRect.w * currentAnim->currentFrame;
    }
  }
}

void Engine::renderSpriteSystem()
{
  // Requires Sprite and Transform
  for (auto &[id, sprite, transform] : ecs.view<Sprite, Transform>())
  {
    // Get the center for rotations
    SDL_FPoint center;
    center.x = (float)transform.position.x;
    center.y = (float)transform.position.y;

    sprite.destinationRect.w = sprite.textureRect.w * sprite.scale.x;
    sprite.destinationRect.h = sprite.textureRect.h * sprite.scale.y;
    // Position is center so box should be started from top-left (half of width)
    sprite.destinationRect.x = transform.position.x - (sprite.destinationRect.w / 2.f);
    sprite.destinationRect.y = transform.position.y - (sprite.destinationRect.h / 2.f);

    if (sprite.debug)
    {
      SDL_SetRenderDrawColor(m_renderer, sprite.debugBoxColor.r, sprite.debugBoxColor.g, sprite.debugBoxColor.b, sprite.debugBoxColor.a);
      SDL_RenderDrawRectF(m_renderer, &sprite.destinationRect);
    }

    SDL_RenderCopyExF(m_renderer, sprite.texture, &sprite.textureRect, &sprite.destinationRect, sprite.rotateAngle, &center, sprite.flip);
  }
}

void Engine::renderAnimationSystem()
{
  for (auto &[id, animator, transform] : ecs.view<Animator, Transform>())
  {
  }
}

#pragma once

#include <SDL2/SDL.h>

#include "../utils/Vec2.h"

struct Collider
{
  Collider(Vec2 center, double width, double height, SDL_Color color = {255, 0, 0, 255})
      : debugColor{color}, center{center}
  {
    box = SDL_FRect{(float)(center.x - width / 2), (float)(center.y - height / 2), (float)width, (float)height};
  }

  Vec2 center;
  // Actual box of the collider
  SDL_FRect box;
  // If debugging then debugColor
  SDL_Color debugColor;
};

#pragma once

#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

#include "../utils/Vec2.h"

// Wrapper to hold and draw texture, the part of the texture to draw
// A box surrounding the texture, angle and flip of texture etc..
class Sprite
{
public:
  SDL_Texture *texture = nullptr;
  SDL_Rect textureRect{0, 0, 0, 0};
  Vec2 scale{1, 1};
  SDL_FRect destinationRect{0, 0, 0, 0};
  double rotateAngle{0};
  SDL_RendererFlip flip{SDL_FLIP_NONE};
  bool debug{false};
  SDL_Color debugBoxColor{255, 0, 0, 255};
};

#pragma once

#include <SDL2/SDL.h>

#include <vector>
#include <algorithm>
#include <cassert>

#include "../utils/Vec2.h"

struct Animation
{
  // The rect to draw from the texture (source rect)
  SDL_Rect frameRect;
  // The x'th number of frame to start from (not in actual pixels but frames)
  int startX = 0;
  // The y'th number of frame to start from (not in actual pixels but frames)
  int startY = 0;
  // The number of frames that this animation has
  int frames;
  // The current frame that is being shown
  int currentFrame;
  // The duration of each frame
  double frameDuration;
  // The time elapsed by the current frame
  double frameTime;
  // Angle to rotate this animation with
  double angle;
};

struct Animator
{
  SDL_Texture *sheet;
  std::vector<Animation *> animations;
  int animationsAdded;
  Vec2 scale;
  int currentAnimation;
  SDL_RendererFlip renderFlipped;

  Animator(SDL_Texture *sheet_arg, size_t nAnimations_arg, Vec2 scale_arg = Vec2(1.f, 1.f))
      : sheet{sheet_arg}, animations{nAnimations_arg, nullptr}, animationsAdded{0},
        scale{scale_arg}, currentAnimation{0}, renderFlipped{SDL_FLIP_NONE}
  {
  }

  void addAnimation(int id, int startX, int startY,
                    int frames, int frameWidth,
                    int frameHeight, double fps,
                    double angle = 0.0)
  {
    assert(!isAssigned(id));
    assert(animationsAdded < animations.size() - 1);

    Animation *newAnimation = new Animation();
    newAnimation->startX = startX;
    newAnimation->startY = startY;
    newAnimation->frameRect.x = startX * frameWidth;
    newAnimation->frameRect.y = startY * frameHeight;
    newAnimation->frameRect.w = frameWidth;
    newAnimation->frameRect.h = frameHeight;

    newAnimation->frames = frames;
    newAnimation->currentFrame = 0;
    newAnimation->frameTime = 0.0;
    newAnimation->frameDuration = 1 / fps; // calculate duration of each animation from fps

    newAnimation->angle = angle;

    animations[id] = newAnimation;
    ++animationsAdded;
  }

  void playAnimation(int id, SDL_RendererFlip flip = SDL_FLIP_NONE)
  {
    // Already playing this animation
    if (id == currentAnimation && flip == renderFlipped)
    {
      return;
    }

    if (!isAssigned(id))
    {
      printf("Animation::remove - Tried playing unkown animation\n");
      return;
    }

    reset(id);
    renderFlipped = flip;
    currentAnimation = id;
  }

  bool isAssigned(int id)
  {
    Animation *found = animations[id];
    return found;
  }

  void reset(int id)
  {
    assert(isAssigned(id));

    Animation *anim = animations[id];
    anim->frameRect.x = anim->startX * anim->frameRect.w;
    anim->frameRect.y = anim->startY * anim->frameRect.h;
    anim->currentFrame = 0;
    anim->frameTime = 0.0;
  }
};